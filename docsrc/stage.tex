
% Desc: Stage user manual
% Author: Richard Vaughan, Andrew Howard
% Date: 10 Jun 2002
% CVS: $Id: stage.tex,v 1.15 2004-06-19 22:59:05 rtv Exp $

\documentclass[letter,11pt,twoside]{report}

% this one apparently fixes the < and > chars
\usepackage[T1]{fontenc}
\usepackage{subfigure}
\usepackage{times}
\usepackage{tabularx}

% why did we need this?
%\usepackage{verbatim}
% make all captions small and slanted
\usepackage[small,sl]{caption}
\usepackage{fullpage}
%\usepackage{epsf}
\usepackage{epsfig}
\usepackage{graphicx}
% add nifty DRAFT watermark thingy in PS
\usepackage{draftcopy}

% A nice environment for displaying command line args (AH)
\newenvironment{xarg}[1]{\noindent{\tt #1}\\\hspace*{2em}\begin{minipage}[t]{5in}}{\end{minipage}\vspace*{1em}}

\def\VERSION {1.5}
\def\HOMEPAGE {{\tt http://playerstage.sourceforge.net}}
\def\SFPAGE {{\tt http://sourceforge.net/projects/playerstage/}}

\begin{document}

\setcounter{page}{0}
\pagenumbering{roman}

\titlepage

 \begin{tabular}{lcr}
   \begin{tabular}{c}
        Player/Stage project\\
         \includegraphics{notext_ps_logo}
    \end{tabular}
   &
   \hspace{5cm}
   &
   \begin{tabular}{r}
     {\bf Autonomy Laboratory}\\
     Simon Fraser University\\
     Burnaby, British Columbia, Canada\\
     \vspace*{2em}\\
     {\bf USC Robotics Laboratory}\\
     University of Southern California\\
     Los Angeles, California, USA\\
     \vspace*{2em}\\
     {\bf Stanford Robotics Laboratory}\\
     Stanford University\\
     Stanford, California, USA\\
   \end{tabular}
 \end{tabular}


  \vspace{4cm}  
  \centerline{ \Huge{Stage}}
  \vspace{0.5cm}
  \centerline{\large{Version \VERSION User Manual}}
  \vspace{2cm}
  \centerline{\large Richard T.~Vaughan \\ Andrew Howard \\ Brian P.~Gerkey}
  \vspace{1cm}

  \centerline{This document may not contain the most current documentation on}
  \centerline{Stage.  For the latest documentation, consult the Player/Stage homepage:}
  \centerline{\HOMEPAGE}

  \vspace{4cm}

 \centerline{\today}

\tableofcontents
%\newpage

%\listoffigures
%\newpage
%\listoftables
%\newpage

% reset page number to start with 1
\setcounter{page}{0}
\pagenumbering{arabic}


\chapter{Introduction}

  %\section{What is Stage?}
\section{ Stage and the Player/Stage Project}

The Player/Stage Project produces software tools to support research
in autonomous robotics and intelligent sensor systems. Stage is a
robot simulator. Stage models a population of mobile robots, sensors
and objects in a two-dimensional bitmapped environment. Stage is
designed with multi-agent systems in mind, so it provides fairly
simple, computationally cheap models of lots of devices rather than
attempting to emulate any device with great fidelity. We have found
this to be a useful approach.

Stage devices are usually controlled through \emph{Player}; a
networked robot server. Player provides a convenient interface to a
set of device drivers for real robots and sensors. Stage simulates a
population of devices and makes them available thorugh Player. Users
write robot controllers and sensor algorithms as `clients' to the
Player `server'. Typically, clients cannot tell the difference between
the real robot devices and their simulated Stage equivalents (unless
they try very hard). We have found that clients developed using Stage
will work with little or no modification with the real robots and vice
versa. Thus Stage allows rapid prototyping of controllers destined for
real robots. Stage also allows experiments with realistic robot
devices you don't happen to have.
  
Various sensors and actuators are provided, including sonar, scanning
laser rangefinder, color-blob tracking, fiducial tracking and mobile
robot bases with odometry. Some models from previous versions may not
be available in this release, but we're working on them.

\section{How to get Stage and related software}

The main resource for Player/Stage is the project
homepage:\\\\ \indent \HOMEPAGE\\

\noindent Access to source code releases, access to the CVS
development tree, bug tracking, user mailing lists, etc.~ is
available from the Sourceforge project management page:\\\\\indent
\SFPAGE\\

\noindent The current release is available as the source tarball
Stage-<version>.src.tgz at:\\\\ \indent
http://sourceforge.net/project/showfiles.php?group\_id=42445\\

Previous versions were significantly different; this manual
does not apply to them.

\section{What's in the Package?}

In the release tarball you will find:
\begin{itemize}
\item C code for the stage communications library.    
\item C and C++ source code for 'stage' the simulation engine.
\item Example environments and setup files.
\end{itemize}



\section{Requirements}

\begin{itemize}
\item X11R6
\item glib
\item GTK+
\item pkg-config
\item libRTK2 [the Player/Stage GUI toolkit \HOMEPAGE] 
\end{itemize}

Optional (but very useful, and recommended if you ever want to use
controller code on real robots):
\begin{itemize}
\item Player [\HOMEPAGE]
\end{itemize}

Stage was developed and tested under Linux kernel 2.4, glibc-2.2 and
OS X.3. Code is reasonable ANSII/POSIX so it often compiles
elsewhere. No promises, but people have found it to work on a variety
of set-ups.

\section{Ownership}

Stage is released under the GNU General Public License. Stage
programs, images, examples, source code and documentation are
ownded and copyrighted by their their authors. The authors are:

\begin{itemize}
\item[] Richard Vaughan [vaughan@sfu.ca]
\item[] Andrew Howard [ahoward@robotics.usc.edu]
\item[] Brian Gerkey [gerkey@robotics.stanford.edu]
\item[] Kasper Stoy [kaspers@robotics.usc.edu]
\item[] Boyoon Jung [boyoon@robotics.usc.edu]
\item[] Jakob Fredslund [jakobf@robotics.usc.edu]
\end{itemize}

See your name here by contributing devices, superior
algorithms, bugfixes, examples, etc.

\section{Bugs and feedback}

This is constantly evolving research software. It is bound to
contain bugs, despite developer and user testing.  If you find
something that appears to be a bug, or if some aspect of Stage's
behavior seems wrong or non-intuitive, let us know. If you have a
problem, please check the website and bug tracking logs. If you
can't find an answer there,{\emph use the bug tracker} to tell us about
the problem. Better still, fix it and send us the patch. To stay
in touch with the developers and other users, join the mailing
lists.

When submitting bugs, include as much information as possible,
including the Stage version, OS type and version, and any output
messages.  A detailed description of what happened will enable us
(hopefully) to repeat and analyze the problem.  Of course, there
is NO WARRANTY on this software, and no guarantee that we will fix
your problem.  But we use Stage for our research and we want it to
work properly, so we will do our best. Again {\emph please use the
  sourceforge bug tracking tools}; that's the best way to see your
problem solved.

\section{Citations}
If you use Player/Stage Project software for your work, please
acknowledge our efforts in your publications. The appropriate
reference for Player is our peer-reviewed article in the proceedings
of IROS 2001: \cite{GerkeyVaughan01a}:
\begin{quote}
  Brian~P. Gerkey, Richard~T. Vaughan, Kasper St\o{}y, Andrew Howard,
  Maja~J Matari\'c and Gaurav~S Sukhatme.
  \newblock {Most Valuable Player: A Robot Device Server for Distributed
    Control}.
  \newblock In {\em Proc. of the IEEE/RSJ Intl. Conf. on Intelligent Robots and
    Systems (IROS)}, pages 1226--1231, Wailea, Hawaii, October 2001.
\end{quote}

At the time of writing, there is no peer-reviewed article about Stage,
but there is a USC technical report, available at:

\begin{quote}
  Richard T.~Vaughan. "Stage: A Multiple Robot Simulator". Technical Report IRIS-00-394, Institute for Robotics and Intelligent Systems, School of Engineering, University of Southern California, 2000.
\end{quote}

The report is out of date on the details of using Stage, but it
explains the motivation and design, which is still relevant.

These papers (and any new ones) are available at: 

\begin{verbatim}
  http://playerstage.sourceforge.net/pubs.html
\end{verbatim}

If you have space (and are feeling generous), you can also insert a footnote
similar to the following:
\begin{quote}
  The Player/Stage Project is a collaboration between the USC Robotics
  Research Lab, Stanford University Robotics Lab, the Autonomy Lab at
  Simon Fraser University, and contributors around the world. All
  Player/Stage software is freely available under the GNU General Public
  License from http://playerstage.sourceforge.net.
\end{quote}
By including such acknowledgements, you do more than feed our egos and
further our careers.  You spread the word about the Player/Stage
project, which will bring more users and developers, as well as please
our funders, ensuring that we will continue hacking on the software.

\section{Acknowledgements}

Stage originated at the University of Southern California Robotics
Labs. Support at USC has come from DARPA grant DABT63-99-1-0015
(MARS), NSF grant ANI-9979457 (SCOWR), DARPA contract
DAAE07-98-C-L028 (TMR), ONR Grants N00014-00-1-0140 and
N0014-99-1-0162, and JPL Contract No. 1216961. Development at HRL
Laboratories was supported by a DARPA contract (SDR). Thanks to
Doug Gage at DARPA IPTO for his long-standing support. Development
at the Autonomy Lab is supported by an NSERC Discovery Grant, SFU
President's Award and faculty start-up grants to Richard Vaughan.

Thanks to our contributors and users, particularly members of the USC
Robotics Lab and playerstage-developers mailing list who have been
generous with their advice, bug reports and fixes, and code
contributions. Many fine people have contributed code to the project,
including (in historical order): Esben \O{}sterg\aa{}rd, Jakob
Fredslund, Boyoon Jung, Jason K. Douglas, Kim Jinsuck, Gabe Sibley,
and Dave Naffin. Various contributed tools and libraries can be found
on the website.

%////////////////////////////////////////////////////////////////////////////
\chapter{Installing and Running Stage}

{\bf This section is under construction. Please refer to the
  README.stage file in the Stage distro for the latest information.}

{\bf Note to users of previous (<1.5) versions:} the build order of
P/S components has changed with v.1.5. The correct build order is:

\begin{enumerate}
\item libRTK
\item Stage
\item Player
\end{enumerate}

\section{Building and Installing Stage}

You must install libRTK {\em before} building Stage, and if, like
most people, you want to use Player with Stage, you must install
Player {\em after} installing Stage. This is because Player uses the
stage client library 'libstage', included with the Stage distro, to
communicate with Stage. Both Stage and Player draw most of their
graphics using libRTK.

All Player/Stage Project components, including Stage, Player and
libRTK are available from the Player/Stage files page:

\begin{verbatim}
  http://sourceforge.net/project/showfiles.php?group_id=42445
\end{verbatim}

\noindent Build and install libRTK following the
instructions in the packages' README and INSTALL files. Now
download the Stage tarball and unpack it with:
\begin{verbatim}
  $ tar xzvf Stage-<version>.tgz
\end{verbatim}
\noindent (where <version> is the most recent release of Stage;
i.e. the largest numbered release not less than 1.5). Now follow the
instructions for your release in the top-level README and INSTALL
files.

\subsection{Notes on specific build targets}

Stage should build on most UNIX-like systems that have GTK
installed. GTK is an essential part of the GNOME desktop system and is
available for many platforms. GTK in turn requires glib and
pkg-config; Stage makes extensive use of these packages. Make sure you
have GTK installed before attempting to install libRTK and Stage.

\subsubsection{Linux}
No special configuration should be required for most Linux distros.

\subsubsection{Solaris}

No special configuration should be required for most Solaris distros.

\subsubsection{Darwin/OS X}
OS X does not have X11 or GTK installed by default. Apple distributes
their own X11 package based on XFree86 which works well. The easiest
way to get GTK and its dependencies installed on OS X is probably via
the excellent ``Fink'' ports system.

You may need to tell the compiler where to find the Fink-installed
headers and libraries using the standard environment variables
\verb+CFLAGS, CPPFLAGS+ and \verb+LIBRARY_PATH+ before building
Stage. For example, if your Fink base directory is /sw (the default):

\begin{verbatim}
   $ export CFLAGS=-I/sw/include
   $ export CPPFLAGS=-I/sw/include
   $ export LIBRARY_PATH=/sw/lib
\end{verbatim}

\subsubsection{Microsoft Windows}
Some people have experimented with building Player and Stage on
Windows, with mixed success. Windows support is not a priority for the
developers, but we're generally interested in cross-platform support
so if you have insight into or experience with getting the system
working on Windows, please let us know.

\section{Running Stage}

 To run Stage do:
 \begin{verbatim} 
  $ stage
 \end{verbatim} 

\section{Command Line Arguments}

<none>

\section{Controlling the robots}

The virtual robots in Stage are controlled by talking to the Stage
server. Player includes drivers for this purpose, based on the
``libstage'' client library included with Stage. Player provides a set
of standard interfaces to a variety of robots, both real and
simulated. Users typically target their controllers to the Player
interfaces so they can then run on real robots or simulated robots in
Stage or Gazebo (a 3D, hi-res robot simulator from the Player/Stage
Project). Example Player controllers in various languages (including C++,
C, Python, TCL \& LISP) are included in the Player distribution.

Try using the Player example client
\verb+<player_root>/utils/playerv/playerv+ to check that you can control
Stage robots and read from their sensors. playerv is a very useful
tool for testing and debugging your controller code.

Client libraries in other languages including Java and Python are also
available. Check the website for the latest resources.

%////////////////////////////////////////////////////////////////////////////
\chapter{Using the Stage GUI}

Stage presents a window showing the state of each simulated world. The
window is resizable and contains a menu and a main display area
showing a view of the world.

\section{World view}
The main display area shows the world, the simulated entities (objects
and devices), and optionally, representations of the data generated by
devices and the configuration of these devices.

\subsection{Mouse}
The user can pan and zoom the world view and manipulate entities with
the mouse:

\subsubsection*{Clicks on the background}

\begin{tabular}{|l|l|}
\hline Mouse action & Result\\\hline
Left-click and drag & pan the window\\
Right-click and drag TOWARDS the center of the window & zoom in\\
Right-click and drag AWAY FROM the center of the window & zoom out\\ 
\hline
\end{tabular}

\subsubsection*{Clicks on entities}
\begin{tabular}{|l|l|}
\hline Mouse action & Result\\\hline
Left-click and drag & move the entity\\
Right-click and drag & rotate the entity\\
\hline
\end{tabular}

\subsection{Keyboard}
The world view can also be panned and zoomed with the keyboard. The
keybindings are:

\subsubsection*{Clicks on entities}
\begin{tabular}{|l|l|}
\hline Key & Action\\ \hline
<arrowkeys>        & scroll the window \\
<ctrl><arrowkeys>  & scroll the window in large increments \\
<shift><uparrow>   & zoom in \\
<shift><downarrow> & zoom out \\
\hline 
\end{tabular}

\section{Menu}

\subsection{File Menu}

\begin{tabular}{|l|l|}
\hline 
Save & save current world state into worldfile\\
Quit & exit Stage\\
\hline
\end{tabular}

\subsection{View Menu}

\begin{tabular}{|l|l|}
\hline 
Grid & toggle view of a 1m grid\\
Matrix & toggle view of underlying bitmap representation\\
Data menu & toggle visualizations of data generated by devices\\
Object menu & toggle visualizations of object bodies\\
Debug & toggle view of debug info, showing raytracing in action\\
\hline
\end{tabular}



%////////////////////////////////////////////////////////////////////////////
\chapter{The World File}
\label{sec:world}

The world file is used to describe the particular set of robots,
sensors and objects to be simulated by Stage.  Stage reads the world
file on start-up and creates entities as indicated in the file.  Stage
may also write updated pose information into the world file when the
user selects the {\bf File:Save} menu option.

Note that the world file format has changed significantly from
previous versions. The script \verb+tools/worldfileconv.tcl+ will
attempt to convert your old (pre Stage-1.2) world files to the new
format.

\section{Basic Syntax}

A simple world file might look like this:
\begin{quote}
\begin{verbatim}
# This world file creates two robots with lasers.

environment 
( 
  file "cave.pnm" 
  scale 0.03 
)

position 
( 
  name "robot1" port 6665 pose [1 1 0] 
  player ()
  laser ()
)

position 
( 
  name "robot2" port 6666 pose [2 1 0] 
  player ()
  laser ()
)
\end{verbatim}
\end{quote}
This example shows the basic syntactic features of the 
world file format: comments, entities and properties.
%
Comments are indicated by the \verb'#' symbol; they may be placed
anywhere in the file and continue to the end of the line.  For
example:
\begin{quote}
\begin{verbatim}
# This world file creates two robots with lasers.
\end{verbatim}
\end{quote}
%
Entities are indicated using \verb'type ( ... )' entries; each such
entry instantiates an entity of type \verb'type'.  For example:
\begin{quote}
\begin{verbatim}
position ( ... )
\end{verbatim}
\end{quote}
creates a single position device (a bare-bones mobile robot).  Entities may
be nested to indicate that one entity is a ``child'' of another; thus:
\begin{quote}
\begin{verbatim}
position ( player () laser() )
\end{verbatim}
\end{quote}
creates a single position device with a Player server and laser attached to
it.  Think of child entities as physically sitting on their parent.
%
Entities have properties, indicated using \verb'name value' pairs:
\begin{quote}
\begin{verbatim}
position ( name "robot1" port 6665 pose [1 1 0] ... )
\end{verbatim}
\end{quote}
This entry creates a position device named ``robot1'' attached to port
6665, with initial position $(1, 1)$ and orientation of $0$.  Property
values can be either numbers (\verb'6665'), strings (indicated by
double quotes \verb'"robot1"') or tuples (indicated by brackets
\verb'[1 1 0]'). 

\section{Defining new entity types}

The \verb'define' statement can be used to define new types of entities.
For example, the world file from the previous section can be re-written
in a more concise form as follows:
\begin{quote}
\begin{verbatim}
# This world file creates two robots with lasers.
# It uses the 'define' construct to define a new type of entity.

environment ( file "cave.pnm" scale 0.03 )

define myrobot position ( player() laser() )

myrobot ( name "robot1" port 6665 pose [1 1 0] )
myrobot ( name "robot2" port 6666 pose [2 1 0] )
\end{verbatim}
\end{quote}
New entities are defined using \verb'define newentity oldentity (...)'.
For example, the line:
\begin{quote}
\begin{verbatim}
define myrobot position ( player() laser() )
\end{verbatim}
\end{quote}
defines a new \verb'myrobot' entity type composed of the
primitive \verb'position', \verb'player' and \verb'laser' entities.
This entity may be instantiated using the standard syntax:
\begin{quote}
\begin{verbatim}
myrobot ( name "robot1" port 6665 pose [1 1 0] )
\end{verbatim}
\end{quote}
This entry creates a position device named \verb'robot1' that has
both \verb'player' and \verb'laser' devices attached.

\section{Using include files}

The \verb'include' statement can be used to include entity definitions
into a world file.  For example, the world file from the previous section
can be divided into an include file called \verb'myrobots.inc':
\begin{quote}
\begin{verbatim}
# This is an include file.
# It uses the 'define' construct to define a new type of entity.

define myrobot position ( player() laser() )
\end{verbatim}
\end{quote}
and a world file called \verb'myworld.world':
\begin{quote}
\begin{verbatim}
# This world file creates two robots with lasers.
# It uses the 'include' statement to include the robot definitions.

include "myrobots.inc"

environment ( file "cave.pnm" scale 0.03 )

myrobot ( name "robot1" port 6665 pose [1 1 0] )
myrobot ( name "robot2" port 6666 pose [2 1 0] )
\end{verbatim}
\end{quote}
The definitions are included using the \verb'include "filename"'
statement.

\section{Units}

The default units for length and angles are meters and degrees
respectively.  Units may be changed using the following global
properties:
\begin{table}[h]
\begin{tabularx}{\columnwidth}{llX}
\hline
Name & Values & Description \\
\hline

\verb'unit_length' & \parbox{30mm}{\verb'"m"'\\\verb'"cm"'\\\verb'"mm"'}
& Set the unit length to meters, centimeters or millimeters. \\

\verb'unit_angle' & \parbox{30mm}{\verb'"degrees"' \\ \verb'"radians"'} &
Set the unit angle to degrees or radians.\\

\hline
\end{tabularx}
\end{table}

\noindent The following example uses millimeters rather than meters
for the unit length unit:
\begin{quote}
\begin{verbatim}
# This world file creates two robots with lasers.
# It uses the 'include' statement to include the robot definitions.

unit_length "mm"

include "myrobots.inc"

environment ( file "cave.pnm" scale 30 )

myrobot ( name "robot1" port 6665 pose [1000 1000 0] )
myrobot ( name "robot2" port 6666 pose [2000 1000 0] )
\end{verbatim}
\end{quote}
Be warned that the length specfication applies to the include files as well,
so choose a unit length early and stick to it.


\section{Examples}

See the {\tt examples} directory in the Stage distribution for more
world file examples.


\chapter{Property Reference - TODO}


Each model has several {\em properties} associated with it; these
properties specify characteristics such as the model's size or sensor
range. The table below lists all of the properties.  The basic
model is implemented in <stage>/src/model.c. Model extensions are
implemented in <stage>/src/model\_<extension>.c.
\vspace{1em}\\
\noindent
\begin{tabularx}{\columnwidth}{lll}
\hline 
Type & Datatype & Description \\
\hline 
STG\_PROP\_GEOM & stg\_geom\_t & size and local pose. \\ 
STG\_PROP\_VELOCITY & stg\_velocity\_t & velocity in x,y,$\theta$. \\
STG\_PROP\_COLOR & stg\_color\_t & RGB color. \\
STG\_PROP\_POSE & stg\_pose\_t & pose in parent's coordinate system. \\
STG\_PROP\_LINES & stg\_line\_t[] & array of lines that define a body. \\

\hline
\end{tabularx}

This is pasted in from stage.h in lieu of writing this section properly.

\begin{verbatim}
    STG_PROP_TIME, // double - time since startup in seconds
    STG_PROP_MASS,
    STG_PROP_COLOR,
    STG_PROP_GEOM, 
    STG_PROP_NAME, // ?
    STG_PROP_PARENT, 
    STG_PROP_PLAYERID,
    STG_PROP_POSE,
    STG_PROP_POWER,
    STG_PROP_ENERGYCONFIG,
    STG_PROP_ENERGYDATA,
    STG_PROP_PUCKRETURN,
    STG_PROP_LINES,
    STG_PROP_VELOCITY, 
    STG_PROP_LASERRETURN,
    STG_PROP_OBSTACLERETURN,
    STG_PROP_VISIONRETURN,
    STG_PROP_RANGERRETURN, 
    STG_PROP_NEIGHBORRETURN,
    STG_PROP_RANGERDATA,
    STG_PROP_RANGERCONFIG,
    STG_PROP_FIDUCIALCONFIG,
    STG_PROP_FIDUCIALDATA,
    STG_PROP_BLOBCONFIG,
    STG_PROP_BLOBDATA,
    STG_PROP_LASERDATA,
    STG_PROP_LASERCONFIG,
    STG_PROP_BLINKENLIGHT,  // light blinking rate
    STG_PROP_NOSE,
    STG_PROP_GRID,
    STG_PROP_LOSMSG,
    STG_PROP_LOSMSGCONSUME,
    STG_PROP_MOVEMASK,
    STG_PROP_BOUNDARY,        // if non-zero, add a bounding rectangle
    STG_PROP_MATRIXRENDER, // if non-zero, render in the matrix
\end{verbatim}

\chapter{WorldFile Reference}

This chapter describes all the possible worldfile options. Worldfile
loading is part of libstage, implemented in <stage>/src/stagecpp.cc.

SI Units are used whenever possible. Distances are specified in
meters, angles in radians, mass in KG, etc. All values in tuples [like
this] are floats.

In addition to the basic model, Stage contains several model
extensions. Each of these adds some properties to the basic model. A
model will only have these properties if they have been explicitly set
 in the worldfile. They do not have default values.


\newpage
\section{Basic model}

\subsection*{Properties}
\begin{tabularx}{\columnwidth}{llX}
\hline
Name & Values & Description \\
\hline

\verb'name' & \verb'string' & A unique name for this entity. This name
is referenced in the Player config file to identify this simulated
device.\\

\verb'pose' & \verb'[x y a]' & Set the pose ([x,y] position and
orientation [a] in the parent's coordinate system).\\

\verb'local_pose' & \verb'[x y a]' & Set the pose ([x,y] position and
orientation [a] in the model's own coordinate system (e.g. to offset a
robot's center of rotation from center of mass).\\

\verb'size' & \verb'[sizex sizey]' & Entity dimensions.\\ 

\verb'mass'& \verb'float' & mass in KG.\\

\verb'velocity'& \verb'[vx vy va]' & forward (vx), sideways (vy)
and rotational (va) velocity.\\

\verb'color' & \verb'string' & Descriptive color (e.g. \verb'"red"' or
\verb'"blue"'); only colors listed in the X11 color database should be used
(look for \verb'rgb.txt' in your X installation).\\

\\
\hline
\end{tabularx}

\subsection*{Defaults}
\begin{tabularx}{\columnwidth}{llX}
\hline
Name & Value\\
\hline
\verb'name' & \verb'""'\\
\verb'size' & \verb'[0 0]'\\
\verb'lines' & a unit rectangle\\
\verb'pose' & \verb'[0 0 0]'\\
\verb'local_pose' & \verb'[0 0 0]'\\
\verb'color' & \verb'"black"'\\
\verb'mass' & \verb'1000.0'\\
\hline
\end{tabularx}

\newpage
\section{Laser model}

The Laser sensor model simulates a scanning laser rangefinder.

\subsection*{Properties}
\begin{tabularx}{\columnwidth}{llX}
\hline
Name & Values & Description \\
\hline

\verb'laser.return' & \parbox{30mm}{\verb'"bright"' \verb'"visible"'
\verb'"invisible"'} & controls how the model appears
to a laser sensor. The \verb'"bright"' value indicates that the
entity is a retro-reflector (and hence produces a high-intensity sample
in the laser).\\

\verb'laser.pose' & \verb'[x y a]' & pose of the laser sensor in local CS.\\

\verb'laser.size'  & \verb'[x y]' & size of the laser sensor. \\

\verb'laser.bounds' & \verb'[min max fov]' & minimum and maximum range
of the laser sensor, and field of view in radians. \\

\verb'laser.samples' & \verb'integer' & the number of samples returned
by the laser. Each sample will correspond to 1/fov radians of the
field of view.\\

\hline \\
\end{tabularx}


\newpage
\section{Fiducuial model}

The Fiducial sensor model locates models that have a non-zero
\verb'fidicial.return' property. It returns the identity, range, bearing,
orientation and size of the detected fiducials (note that Player's
fiducial interface does not return an individual size for each
fiducial).

\subsubsection*{Properties}
\begin{tabularx}{\columnwidth}{llX}
\hline
Name & Values & Description \\
\hline

\verb'fiducial.return' & \verb'integer' & the value returned if we are
inspected by a fidicual finder. Set to zero to be invisible (so the
sensor can't see you or the things behind you), or -1 to be
transparent (so the sensor can see right through you).\\

\verb'fiducial.bounds' & \verb'[min max fov]' & the minimum and
maximum range of the sensor in meters, and its field of view in
radians.\\

\verb'fiducial.id_limit' & \verb'float' & the maximum range at which a
fiducial's ID can be read. If this is < 0, the sensor's maximum range
is used.\\ \hline
\end{tabularx}

\newpage
\section{Position model}

The Position model simulates a mobile robot base. It allows clients to
drive a model around, and to read odometry data.

\subsection*{Properties}
\begin{tabularx}{\columnwidth}{llX}
\hline
Name & Values & Description \\
\hline

\verb'position.return' & \parbox{30mm}{\verb'"visible"'
\verb'"invisible"'} & Specifies whether or not this object is an
obstacle for collision detection.\\

\verb'position.drive' & \verb'"diff"' or \verb'"omni"' & Selects differential or omnidirectional drive\\

%\verb'init_odom' & \verb'[x y a]' & Initial odometry (position and orientation).\\
%\verb'reset_if_no_subscribers' & \verb'"yes"' or \verb'"no"' & If \verb'"yes"', 
%then the odometry will be reset to 0.0, 0.0, 0.0 if no clients are subscribed
%(Prior versions of Stage always did this.)
%If \verb'"no"', then previous values will remain.
\\
\hline
\end{tabularx}

\newpage
\section{Ranger model}

The Ranger sensor model simulates an array of rangefinders. It
approximates real-world sonar and infrared rangefinders.

\subsection*{Properties}
\begin{tabularx}{\columnwidth}{llX}
\hline
Name & Values & Description \\
\hline

\verb'ranger.return' & \parbox{30mm}{\verb'"visible"'
\verb'"invisible"'} & Specifies whether or not this entity will be
detected by ranger sensors.\\

\verb'ranger.count' & \verb'integer' & The number of ranger transducers.\\
\verb'ranger[i].pose' & \verb'[x y a]' & The pose of transducer \verb'i' in
local coordinates.\\
\verb'ranger[i].bounds' & \verb'[min max]' & The minimum and maximum
range of transducer \verb'i'.\\
\hline
\end{tabularx}


\newpage
\section{Blobfinder model}

The Blobfinder sensor model simulates color-blob-tracking devices such
as ACTS and the CMUCam.

\subsection*{Properties}
\begin{tabularx}{\columnwidth}{llX}
\hline Name & Values & Description \\ 
\hline 

\verb'blob.return' & \parbox{30mm}{\verb'"visible"'
\verb'"invisible"'} & Specifies whether or not this entity will be
seen by a blobfinder; the channel in which we appear is determined by
our \verb'color' property and the viewer's \verb'blob.channels'
property.\\

\verb'blob.count' & \verb'integer' & the number of color channels to
track.\\

\verb'blob.channels' & \verb'["color0" "color1" ...]' & The
color detected by each channel.  Descriptive
color names from the X11 color database should be used
(e.g. \verb'"red"' or \verb'"blue"').  Look for \verb'rgb.txt' in your
X installation).\\
\hline
\end{tabularx}

\newpage
\section{Energy model}

The Energy model simulates battery energy storage, expenditure and
recharging. A model can be configured to have a charging probe. If the
probe touches another object, energy is transferred from the probee to
the prober.

\subsection*{Properties}
\begin{tabularx}{\columnwidth}{llX}
\hline Name & Values & Description \\ 
\hline 

\verb'energy.return' & \verb'float' & The amount of energy per second
this device will supply when probed. \\
\verb'energy.capacity' & \verb'float' & Storage capacity in Joules.\\
\verb'energy.probe_range' & \verb'float' & Length of our charging probe.\\
\hline
\end{tabularx}

%------------------------------------
\chapter{libstage API Reference - TODO}

The Stage distribution includes the libstage C library that makes it
easy to write clients to the Stage server. libstage is used by
Player's Stage drivers.


\section{Client}

\section{World}

\section{Model}


\bibliographystyle{plain}
\bibliography{playerstage}


\end{document}
