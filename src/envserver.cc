#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <iomanip.h>
#include <termios.h>
#include <strstream.h>
#include <iostream.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <math.h>
#include <sys/time.h>
#include <unistd.h>

#include <queue>

//#define DEBUG
//#define VERBOSE

#include "world.hh"
#include "truthserver.hh"

extern  CWorld* world;

const int LISTENQ = 128;
//const long int MILLION = 1000000L;

extern void CatchSigPipe( int signo );

void CWorld::EnvWriter( int connfd )
{
#ifdef VERBOSE
  printf( "Stage: EnvWriter thread\n" );
  fflush( stdout );
#endif

  stage_env_header_t hdr;

  hdr.width = (uint16_t)world->matrix->width;
  hdr.height = (uint16_t)world->matrix->height;
  hdr.ppm = (uint16_t)world->ppm;
  hdr.num_objects = (uint16_t)world->GetObjectCount();
  hdr.num_pixels = 0; // we'll count them below

  for( int x = 0; x < world->matrix->width; x++ )
    for( int y = 0; y < world->matrix->height; y++ )
      if( world->matrix->is_type( x, y, WallType ) )
	hdr.num_pixels++;
  
  int errorretval = -1;

  // send the header to the connected client
  if( write( connfd, &hdr, sizeof(hdr) ) < 0 )
    {
      perror( "EnvWriter failed writing header" );
      close( connfd );
      pthread_exit( (void*)&errorretval );
    }

  // while the client is reading that, we'll process he pixels

  // allocate storage for the filled pixels
  XPoint* pixels = new XPoint[ hdr.num_pixels ];
  
  memset( pixels, 0, hdr.num_pixels * sizeof( XPoint ) );

  int store = 0;
  // iterate through again, this time recording the pixel's details
  for( int x = 0; x < world->matrix->width; x++ )
    for( int y = 0; y < world->matrix->height; y++ )
      {
	if( world->matrix->is_type( x, y, WallType ) )
	  {
	    pixels[store].x = x;
	    pixels[store].y = y;
	    
	    store++;
	  }
      }
  
  
  // send the pixels
  int send = hdr.num_pixels*sizeof(XPoint);
  int sent = 0;

#ifdef VERBOSE      
      printf( "Stage: EnvWriter sending %d pixels (%d bytes)\n", 
	      hdr.num_pixels, send );
      fflush( stdout );
#endif

  while( sent < send )
    {
      int b = write( connfd, pixels, send - sent );
  
      if( b < 0 )
	{
	  perror( "EnvWriter failed writing pixels" );
	  close( connfd );
	  pthread_exit( (void*)&errorretval );
	}
      
      sent += b;

#ifdef VERBOSE      
      printf( "Stage: EnvWriter sent %d/%d bytes\n", sent, send );
      fflush( stdout );
#endif
      
    }

  stage_truth_t truth;

  for( int n=0; n<hdr.num_objects; n++ )
    {
      world->GetObject(n)->ComposeTruth( &truth, n );
      
      // send the truth
      send = sizeof(stage_truth_t);
      sent = 0;
      
#ifdef VERBOSE      
      printf( "Stage: EnvWriter sending %d truths (%d bytes)\n", 
	      1, send );
      fflush( stdout );
#endif
      
      while( sent < send )
	{
	  int b = write( connfd, &truth, send - sent );
	  
	  if( b < 0 )
	    {
	      perror( "EnvWriter failed writing truths" );
	      close( connfd );
	      pthread_exit( (void*)&errorretval );
	    }
	  
	  sent += b;
	  
#ifdef VERBOSE      
	  printf( "Stage: EnvWriter sent %d/%d bytes\n", sent, send );
	  fflush( stdout );
#endif
	  
	}
    }
  
  close( connfd );
}	

void CWorld::SetupEnvServer( void )
{
  m_env_listen.fd = socket(AF_INET, SOCK_STREAM, 0);
  m_env_listen.events = POLLIN; // notify me when a connection request happens

  struct sockaddr_in servaddr;  
  bzero(&servaddr, sizeof(servaddr));

  servaddr.sin_family      = AF_INET;
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servaddr.sin_port        = htons(m_env_port);
  
  // switch on the re-use-address option
  const int on = 1;
  setsockopt( m_env_listen.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on) );
  
  if( bind(m_env_listen.fd, (SA *) &servaddr, sizeof(servaddr) )  < 0 )
    {
      perror("CWorld::SetupEnvServer()");
      cout << "Port " << m_env_port 
	   << " is in use. Quitting (but try again in a few seconds)." 
	   <<endl;
      exit( -1 );
    }
 
  // catch signals generated by socket closures
   signal( SIGPIPE, CatchSigPipe );
 
   // listen for requests on this socket
   // we poll it in ListenForEnvConnections()
   assert( listen( m_env_listen.fd, LISTENQ) == 0 );
}

void CWorld::ListenForEnvConnections( void )
{ 
  int readable = 0;
  
  // poll for connection requests with a very fast timeout
  if((readable = poll( &m_env_listen, 1, 0 )) == -1)
    {
      if( errno != EINTR ) // timer interrupts are OK
	{ 
	  perror( "Stage warning: poll error (not EINTR)");
	  return;
	}
    }
  
  // if the socket had a request
  if( readable && (m_env_listen.revents & POLLIN ) ) 
    {
      // set up a socket for this connection
      struct sockaddr_in cliaddr;  
      bzero(&cliaddr, sizeof(cliaddr));
      socklen_t clilen = sizeof(cliaddr);
      
      int connfd = accept( m_env_listen.fd, (SA *) &cliaddr, &clilen);

      assert( connfd > 0 );
      
#ifdef VERBOSE
      printf( "Stage: EnvWriter connection accepted (socket %d)\n", connfd );
      fflush( stdout );
#endif
      // write the world state into the socket
      EnvWriter( connfd );
    }
}

